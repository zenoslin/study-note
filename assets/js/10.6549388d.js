(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{192:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"压缩图片桌面应用-imagemin-electron"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩图片桌面应用-imagemin-electron","aria-hidden":"true"}},[e._v("#")]),e._v(" \b\b 压缩图片桌面应用 imagemin-electron")]),e._v(" "),t("p",[e._v("基于"),t("code",[e._v("electron")]),e._v("制作一个"),t("code",[e._v("node")]),e._v("压缩图片的桌面应用")]),e._v(" "),t("p",[e._v("下载地址："),t("a",{attrs:{href:"https://github.com/zenoslin/imagemin-electron/releases",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/zenoslin/imagemin-electron/releases"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("项目源码 Github："),t("a",{attrs:{href:"https://github.com/zenoslin/imagemin-electron",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/zenoslin/imagemin-electron"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"准备工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#准备工作","aria-hidden":"true"}},[e._v("#")]),e._v(" 准备工作")]),e._v(" "),t("p",[e._v("我们来整理一下我们需要做什么：")]),e._v(" "),t("ul",[t("li",[e._v("\b\b 压缩图片模块")]),e._v(" "),t("li",[e._v("获取文件路径")]),e._v(" "),t("li",[e._v("桌面应用生成")])]),e._v(" "),t("h2",{attrs:{id:"压缩图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩图片","aria-hidden":"true"}},[e._v("#")]),e._v(" 压缩图片")]),e._v(" "),t("p",[e._v("我们需要 \b 使用"),t("code",[e._v("imagemin")]),e._v("这个库来压缩图片，这里我们把这个库封装成压缩模块。")]),e._v(" "),t("div",{staticClass:"language-- js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const imagemin = require('imagemin')\nconst imageminMozjpeg = require('imagemin-mozjpeg')\nconst imageminPngquant = require('imagemin-pngquant')\nconst imageminGifsicle = require('imagemin-gifsicle')\n\nasync function compass(input, output, opts, callback) {\n    let log = await imageminCompass(input, output, opts)\n    callback(log)\n}\n\nasync function imageminCompass(input, output = 'temp', opts = {}) {\n    input = (typeof input == 'string') ? [input] : input;\n    return await imagemin(input, output, {\n            use: [\n                imageminMozjpeg(opts),\n                imageminPngquant(opts),\n                imageminGifsicle({\n                    optimizationLevel:3\n                })\n            ]\n        })\n        .then(file => {\n            return {\n                status: true,\n                data: file\n            };\n        })\n        .catch(e => {\n            console.log(e);\n            return {\n                status: false,\n                error: e.toString()\n            }\n        });\n}\n\nmodule.exports = {\n    compass: compass\n};\n")])])]),t("h2",{attrs:{id:"获取文件路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取文件路径","aria-hidden":"true"}},[e._v("#")]),e._v(" \b 获取文件路径")]),e._v(" "),t("p",[e._v("在我的理解中，electron 用的是一个 mini 版的 chrome 浏览器，然后帮我们实现了浏览器跟系统(win & mac)交互的的许多 api 接口。")]),e._v(" "),t("p",[e._v("我们可以通过正常写网页的方式进行开发，当需要进行与系统交互的操作时，我们只需要在我们网页中的 js 进程（这里应该叫做这个桌面应用的渲染进程）抛出一个事件，然后在 electron 的主进程进行监听，收到事件后调用相应的 api 接口，结果再反过来用事件的方式抛给渲染进程。")]),e._v(" "),t("p",[e._v("electron 的安装和学习可以上官网"),t("a",{attrs:{href:"https://electronjs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://electronjs.org/"),t("OutboundLink")],1),e._v("进行学习。")]),e._v(" "),t("p",[e._v("ps：这里有一个 electron 的坑说一下，electron 和 jquery 存在冲突，所以直接用"),t("code",[e._v("script")]),e._v("标签引入会失败，在 \b"),t("code",[e._v("windows")]),e._v("对象中找不到"),t("code",[e._v("j\bQuery")]),e._v("对象。这里我们可以加这么一句解决。")]),e._v(" "),t("div",{staticClass:"language--html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<script src=\"./src/jquery.min.js\"><\/script>\n<script>if (typeof module === 'object') {window.jQuery = window.$ = module.exports;};<\/script>\n")])])]),t("p",[e._v("回到正题，首先我们在"),t("code",[e._v("index.html")]),e._v("中增加一个按钮来打开系统的路径选择器。")]),e._v(" "),t("div",{staticClass:"language--html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<button id="input-btn">选择路径</button>\n')])])]),t("p",[e._v("在 \b 渲染进程"),t("code",[e._v("renderer.js")]),e._v("\b 中，监听按钮的点击，以及监听主线程返回的事件。")]),e._v(" "),t("div",{staticClass:"language--js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const {ipcRenderer} = require('electron')\nconst inputBtn = document.getElementById('input-btn')\n\ninputBtn.addEventListener('click', (event) => {\n    console.log('点击输入按钮')\n    ipcRenderer.send('open-file-dialog-input')\n})\n\nipcRenderer.on('input-path', (event, path) => {\n    console.log(`收到完成信息 ${path}`)\n    _inputPath = path\n    inputPath.value = `${path}`\n})\n")])])]),t("p",[e._v("在主进程"),t("code",[e._v("main.js")]),e._v("中，监听渲染进程抛出的事件，并调用 api 接口后放回结果。")]),e._v(" "),t("div",{staticClass:"language--js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ipcMain.on('open-file-dialog-input', (event) => {\n    dialog.showOpenDialog({\n        properties: ['openFile', 'openDirectory']\n    }, (files) => {\n        if (files) {\n            console.log('发出完成信息')\n            event.sender.send('input-path', files)\n        }\n    })\n})\n")])])]),t("p",[e._v("这样我们完成了使用系统 api 接口选择路径的功能。但其实我们实际的使用场景中路径选择器的方式并不是特别的方便，所以我们实现另一个功能 \b\b。")]),e._v(" "),t("p",[e._v("拖动将文件或者文件夹拖入网页中，获取到对应的路径。这里使用了"),t("code",[e._v("js")]),e._v("+"),t("code",[e._v("div")]),e._v("实现了这个功能。")]),e._v(" "),t("p",[e._v("index.html")]),e._v(" "),t("div",{staticClass:"language-- html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!--可拖入区域--\x3e\n<div id="holder" class="jumbotron holder">\n</div>\n<style>\n        /* 拖拽的区域样式 */\n        .holder {\n            min-height: 200px;\n            background: #eee;\n            margin: 2em;\n            padding: 1em;\n            border: 0px dotted #eee;\n            border-radius: 10px;\n            transition: .3s all ease-in-out;\n        }\n\n        /* 拖拽时用jQuery为其添加边框样式的class */\n        .holder-ondrag {\n            border: 20px dotted #d45700;\n        }\n</style>\n')])])]),t("p",[e._v("renderer.js")]),e._v(" "),t("div",{staticClass:"language--js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const holder = document.getElementById("holder")\n\nholder.ondragenter = holder.ondragover = (event) => {\n    event.preventDefault()\n    holder.className = "jumbotron holder-ondrag"\n}\n\nholder.ondragleave = (event) => {\n    event.preventDefault()\n    holder.className = "jumbotron holder"\n}\n\nholder.ondrop = (event) => {\n    // 调用 preventDefault() 来避免浏览器对数据的默认处理\n    //（drop 事件的默认行为是以链接形式打开\n    event.preventDefault()\n    holder.className = "jumbotron holder"\n    var file = event.dataTransfer.files[0]\n    _inputPath = inputPath.value = file.path\n}\n')])])]),t("p",[e._v("将我们 \b 获取到的文件路径传入 \b 前面编写的压缩文件模块，这样我们就可以完成了图片的压缩。")]),e._v(" "),t("h2",{attrs:{id:"桌面应用生成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#桌面应用生成","aria-hidden":"true"}},[e._v("#")]),e._v(" 桌面应用生成")]),e._v(" "),t("p",[e._v("最后，我们利用"),t("a",{attrs:{href:"https://github.com/electron-userland/electron-packager",target:"_blank",rel:"noopener noreferrer"}},[e._v("electron-packager"),t("OutboundLink")],1),e._v("完成对"),t("code",[e._v("electron")]),e._v("桌面应用的打包。")]),e._v(" "),t("div",{staticClass:"language--sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//\bmac\n\belectron-packager . --out=out --platform=mas --arch=x64\n//win\nelectron-packager . --platform=win32 --arch=x64\n")])])]),t("p",[e._v("ps：在非 Windows 主机平台上进行打包，需要安装 Wine 1.6 或更高版本")])])},[],!1,null,null,null);n.default=r.exports}}]);